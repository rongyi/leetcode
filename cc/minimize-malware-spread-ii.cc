// http://leetcode.com/problems/minimize-malware-spread-ii/description/
#include "xxx.hpp"

class Solution {
public:
  int minMalwareSpread(vector<vector<int>> &graph, vector<int> &initial) {
    int ret = 0;
    int min_count = graph.size();

    sort(initial.begin(), initial.end());

    for (auto drop : initial) {
      int cur_count = bfs(graph, initial, drop);
      if (cur_count < min_count) {
        min_count = cur_count;
        ret = drop;
      }
    }
    return ret;
  }

private:
  int bfs(vector<vector<int>> &graph, vector<int> &initial, int drop) {
    queue<int> q;
    unordered_set<int> visited{drop};
    int ret = 0;
    // 所有其他节点入队
    for (auto i : initial) {
      if (i != drop) {
        q.push(i);
      }
    }

    while (!q.empty()) {
      int cur = q.front();
      q.pop();
      if (visited.find(cur) != visited.end()) {
        continue;
      }
      visited.insert(cur);
      ret++;
      for (int i = 0; i < graph.size(); i++) {
        if (i != cur && graph[cur][i]) {
          q.push(i);
        }
      }
    }

    return ret;
  }
};
