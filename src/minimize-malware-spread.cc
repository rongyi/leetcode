// http://leetcode.com/problems/minimize-malware-spread/description/
#include "xxx.h"

class Solution {
public:
  int minMalwareSpread(vector<vector<int>> &graph, vector<int> &initial) {
    // n * n graph
    const int n = graph.size();
    parent_ = vector<int>(n, -1);

    unordered_map<int, int> count;
    for (int i = 0; i < n; i++) {
      // 至少包含它自己嘛
      count[i] = 1;
    }

    // 构造union集团
    for (int i = 0; i < n; i++) {
      // 因为是对称的，所以取半边即可
      for (int j = i + 1; j < n; j++) {
        // connected
        if (graph[i][j] == 1) {
          int parx = find(i);
          int pary = find(j);
          if (parx != pary) {
            mkunion(parx, pary);
            count[parx] += count[pary];
          }
        }
      }
    }
    int ret = numeric_limits<int>::max();
    // 默认序号最小的那个
    const int msize = initial.size();
    for (int i = 0; i < msize; i++) {
      ret = min(ret, initial[i]);
    }

    unordered_map<int, int> seen;
    for (int i = 0; i < msize; i++) {
      int par = find(initial[i]);
      seen[par]++;
    }

    int maxi = 0;

    for (int i = 0; i < msize; i++) {
      int par = find(initial[i]);
      if (seen[par] == 1) {
        if (count[par] > maxi) {
          maxi = count[par];
          ret = initial[i];
        } else if (count[par] == maxi) {
          ret = min(ret, initial[i]);
        }
      }
    }
    return ret;
  }

private:
  int find(int x) {
    if (parent_[x] == -1) {
      return x;
    }
    return find(parent_[x]);
  }
  // merge y to x
  void mkunion(int x, int y) {
    parent_[y] = x;
    parent_[x] = -1;
  }

private:
  vector<int> parent_;
};
